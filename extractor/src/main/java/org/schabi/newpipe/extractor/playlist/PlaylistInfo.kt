package org.schabi.newpipe.extractor.playlist

import org.schabi.newpipe.extractor.Image
import org.schabi.newpipe.extractor.ListExtractor.InfoItemsPage
import org.schabi.newpipe.extractor.ListInfo
import org.schabi.newpipe.extractor.NewPipe
import org.schabi.newpipe.extractor.Page
import org.schabi.newpipe.extractor.StreamingService
import org.schabi.newpipe.extractor.exceptions.ExtractionException
import org.schabi.newpipe.extractor.linkhandler.ListLinkHandler
import org.schabi.newpipe.extractor.stream.Description
import org.schabi.newpipe.extractor.stream.StreamInfoItem
import org.schabi.newpipe.extractor.utils.ExtractorHelper
import java.io.IOException

class PlaylistInfo private constructor(serviceId: Int, linkHandler: ListLinkHandler?, name: String?) : ListInfo<StreamInfoItem?>(serviceId, linkHandler, name) {
    /**
     * Mixes are handled as particular playlists in NewPipeExtractor. [PlaylistType.NORMAL] is
     * for non-mixes, while other values are for the different types of mixes. The type of a mix
     * depends on how its contents are autogenerated.
     */
    enum class PlaylistType {
        /**
         * A normal playlist (not a mix)
         */
        NORMAL,

        /**
         * A mix made only of streams related to a particular stream, for example YouTube mixes
         */
        MIX_STREAM,

        /**
         * A mix made only of music streams related to a particular stream, for example YouTube
         * music mixes
         */
        MIX_MUSIC,

        /**
         * A mix made only of streams from (or related to) the same channel, for example YouTube
         * channel mixes
         */
        MIX_CHANNEL,

        /**
         * A mix made only of streams related to a particular (musical) genre, for example YouTube
         * genre mixes
         */
        MIX_GENRE
    }

    var uploaderUrl: String? = ""
    var uploaderName: String? = ""
    var subChannelUrl: String? = null
    var subChannelName: String? = null
    var description: Description? = null

    @get:Nonnull
    @Nonnull
    var banners: List<Image?>? = listOf<Image>()

    @get:Nonnull
    @Nonnull
    var subChannelAvatars: List<Image?>? = listOf<Image>()

    @get:Nonnull
    @Nonnull
    var thumbnails: List<Image?>? = listOf<Image>()

    @get:Nonnull
    @Nonnull
    var uploaderAvatars: List<Image?>? = listOf<Image>()
    var streamCount: Long = 0
    var playlistType: PlaylistType? = null

    companion object {
        @Throws(IOException::class, ExtractionException::class)
        fun getInfo(url: String): PlaylistInfo {
            return getInfo(NewPipe.getServiceByUrl(url), url)
        }

        @Throws(IOException::class, ExtractionException::class)
        fun getInfo(service: StreamingService?, url: String?): PlaylistInfo {
            val extractor: PlaylistExtractor? = service!!.getPlaylistExtractor(url)
            extractor!!.fetchPage()
            return getInfo(extractor)
        }

        @Throws(IOException::class, ExtractionException::class)
        fun getMoreItems(service: StreamingService,
                         url: String?,
                         page: Page?): InfoItemsPage<StreamInfoItem?>? {
            return service.getPlaylistExtractor(url)!!.getPage(page)
        }

        /**
         * Get PlaylistInfo from PlaylistExtractor
         *
         * @param extractor an extractor where fetchPage() was already got called on.
         */
        @Throws(ExtractionException::class)
        fun getInfo(extractor: PlaylistExtractor?): PlaylistInfo {
            val info: PlaylistInfo = PlaylistInfo(
                    extractor.getServiceId(),
                    extractor.getLinkHandler(),
                    extractor.getName())
            // collect uploader extraction failures until we are sure this is not
            // just a playlist without an uploader
            val uploaderParsingErrors: MutableList<Throwable?> = ArrayList()
            try {
                info.setOriginalUrl(extractor.getOriginalUrl())
            } catch (e: Exception) {
                info.addError(e)
            }
            try {
                info.streamCount = extractor.getStreamCount()
            } catch (e: Exception) {
                info.addError(e)
            }
            try {
                info.description = extractor.getDescription()
            } catch (e: Exception) {
                info.addError(e)
            }
            try {
                info.thumbnails = extractor.getThumbnails()
            } catch (e: Exception) {
                info.addError(e)
            }
            try {
                info.uploaderUrl = extractor.getUploaderUrl()
            } catch (e: Exception) {
                uploaderParsingErrors.add(e)
            }
            try {
                info.uploaderName = extractor.getUploaderName()
            } catch (e: Exception) {
                uploaderParsingErrors.add(e)
            }
            try {
                info.uploaderAvatars = extractor.getUploaderAvatars()
            } catch (e: Exception) {
                uploaderParsingErrors.add(e)
            }
            try {
                info.subChannelUrl = extractor.getSubChannelUrl()
            } catch (e: Exception) {
                uploaderParsingErrors.add(e)
            }
            try {
                info.subChannelName = extractor.getSubChannelName()
            } catch (e: Exception) {
                uploaderParsingErrors.add(e)
            }
            try {
                info.subChannelAvatars = extractor.getSubChannelAvatars()
            } catch (e: Exception) {
                uploaderParsingErrors.add(e)
            }
            try {
                info.banners = extractor.getBanners()
            } catch (e: Exception) {
                info.addError(e)
            }
            try {
                info.playlistType = extractor.getPlaylistType()
            } catch (e: Exception) {
                info.addError(e)
            }

            // do not fail if everything but the uploader infos could be collected (TODO better comment)
            if ((!uploaderParsingErrors.isEmpty()
                            && (!info.getErrors().isEmpty() || uploaderParsingErrors.size < 3))) {
                info.addAllErrors(uploaderParsingErrors)
            }
            val itemsPage: InfoItemsPage<StreamInfoItem?>? = ExtractorHelper.getItemsPageOrLogError(info, (extractor)!!)
            info.setRelatedItems(itemsPage.getItems())
            info.setNextPage(itemsPage.getNextPage())
            return info
        }
    }
}
